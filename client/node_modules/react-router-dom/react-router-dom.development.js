import{Router,useHref,useNavigate,useLocation,useResolvedPath,useBlocker}from'react-router';import{createBrowserHistory,createHashHistory,createPath}from'history';import PropTypes from'prop-types';import{useRef,useReducer,useLayoutEffect,createElement,forwardRef,useCallback,useMemo}from'react';export{MemoryRouter,Navigate,Outlet,Route,Router,Routes,createRoutesFromArray,createRoutesFromChildren,generatePath,matchPath,matchRoutes,resolvePath,useBlocker,useHref,useInRouterContext,useLocation,useMatch,useNavigate,useOutlet,useParams,useResolvedPath,useRoutes}from'react-router';function k(b,c){if(!b){"undefined"!==typeof console&&console.warn(c);try{throw Error(c);}catch(d){}}}function m({children:b,window:c}){let d=useRef();null==d.current&&(d.current=createBrowserHistory({window:c}));let a=d.current,[f,h]=useReducer((a,b)=>b,{action:a.action,location:a.location});useLayoutEffect(()=>a.listen(h),[a]);return createElement(Router,{children:b,action:f.action,location:f.location,navigator:a})}m.displayName="BrowserRouter";m.propTypes={children:PropTypes.node,window:PropTypes.object};
function n({children:b,window:c}){let d=useRef();null==d.current&&(d.current=createHashHistory({window:c}));let a=d.current,[f,h]=useReducer((b,a)=>a,{action:a.action,location:a.location});useLayoutEffect(()=>a.listen(h),[a]);return createElement(Router,{children:b,action:f.action,location:f.location,navigator:a})}n.displayName="HashRouter";n.propTypes={children:PropTypes.node,window:PropTypes.object};
let q=forwardRef(function({onClick:b,replace:c=!1,state:d,target:a,to:f,...h},p){let l=useHref(f),r=useNavigate(),t=useLocation(),g=useResolvedPath(f);return createElement("a",Object.assign({},h,{href:l,onClick:function(e){b&&b(e);e.defaultPrevented||0!==e.button||a&&"_self"!==a||e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||(e.preventDefault(),e=!!c||createPath(t)===createPath(g),r(f,{replace:e,state:d}))},ref:p,target:a}))});q.displayName="Link";
q.propTypes={onClick:PropTypes.func,replace:PropTypes.bool,state:PropTypes.object,target:PropTypes.string,to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired};
let u=forwardRef(function({"aria-current":b="page",activeClassName:c="active",activeStyle:d,caseSensitive:a=!1,className:f="",end:h=!1,style:p,to:l,...r},t){var g=useLocation(),e=useResolvedPath(l);g=g.pathname;e=e.pathname;a||(g=g.toLowerCase(),e=e.toLowerCase());b=(a=h?g===e:g.startsWith(e))?b:void 0;c=[f,a?c:null].filter(Boolean).join(" ");return createElement(q,Object.assign({},r,{"aria-current":b,className:c,ref:t,style:{...p,...a?d:null},to:l}))});u.displayName="NavLink";
u.propTypes={...q.propTypes,"aria-current":PropTypes.oneOf("page step location date time true".split(" ")),activeClassName:PropTypes.string,activeStyle:PropTypes.object,className:PropTypes.string,style:PropTypes.object,to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired};function v({message:b,when:c}){w(b,c);return null}v.displayName="Prompt";v.propTypes={message:PropTypes.string,when:PropTypes.bool};
function w(b,c=!0){let d=useCallback(a=>{window.confirm(b)&&a.retry()},[b]);useBlocker(d,c)}function x(b=""){return new URLSearchParams("string"===typeof b||Array.isArray(b)||b instanceof URLSearchParams?b:Object.keys(b).reduce((c,d)=>{let a=b[d];return c.concat(Array.isArray(a)?a.map(a=>[d,a]):[[d,a]])},[]))}


function useSearchParams(b){k("undefined"!==typeof URLSearchParams,"You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");let c=
useRef(x(b)),d=useLocation();b=useMemo(()=>{let a=x(d.search);for(let b of c.current.keys())a.has(b)||c.current.getAll(b).forEach(c=>{a.append(b,c)});return a},[d.search]);let a=useNavigate(),f=useCallback((b,c)=>{a("?"+x(b),c)},[a]);return[b,f]};export{m as BrowserRouter,n as HashRouter,q as Link,u as NavLink,v as Prompt,x as createSearchParams,w as usePrompt,useSearchParams}
//# sourceMappingURL=react-router-dom.development.js.map
