import{createMemoryHistory,Action,parsePath}from'history';import PropTypes from'prop-types';import{createContext,useRef,useReducer,useLayoutEffect,createElement,useContext,useEffect,useMemo,useCallback,Children,isValidElement,Fragment}from'react';function h(a,b){if(!a)throw Error(b);}function k(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}let l={};function m(a,b,c){b||l[a]||(l[a]=!0,k(!1,c))}let q=createContext({static:!1});q.displayName="Location";let r=createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});r.displayName="Route";
function t({children:a,initialEntries:b,initialIndex:c}){let d=useRef();null==d.current&&(d.current=createMemoryHistory({initialEntries:b,initialIndex:c}));let e=d.current,[f,g]=useReducer((b,a)=>a,{action:e.action,location:e.location});useLayoutEffect(()=>e.listen(g),[e]);return createElement(u,{children:a,action:f.action,location:f.location,navigator:e})}t.displayName="MemoryRouter";
t.propTypes={children:PropTypes.node,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};
function v({to:a,replace:b,state:c}){w()?void 0:h(!1,"<Navigate> may be used only in the context of a <Router> component.");k(!useContext(q).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let d=x();useEffect(()=>{d(a,{replace:b,state:c})});return null}v.displayName="Navigate";
v.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function y(){return z()}y.displayName="Outlet";y.propTypes={};function A({element:a=createElement(y,null)}){return a}A.displayName="Route";A.propTypes={caseSensitive:PropTypes.bool,children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};
function u({children:a=null,action:b=Action.Pop,location:c,navigator:d,static:e=!1}){w()?h(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;return createElement(q.Provider,{children:a,value:{action:b,location:c,navigator:d,static:e}})}u.displayName="Router";
u.propTypes={children:PropTypes.node,action:PropTypes.oneOf(["POP","PUSH","REPLACE"]),location:PropTypes.object.isRequired,navigator:PropTypes.shape({createHref:PropTypes.func.isRequired,push:PropTypes.func.isRequired,replace:PropTypes.func.isRequired,go:PropTypes.func.isRequired,block:PropTypes.func.isRequired}).isRequired,static:PropTypes.bool};function B({basename:a="",children:b}){b=C(b);return D(b,a)}B.displayName="Routes";B.propTypes={basename:PropTypes.string,children:PropTypes.node};
function w(){return null!=useContext(q).location}function E(){w()?void 0:h(!1,"useLocation() may be used only in the context of a <Router> component.");return useContext(q).location}
function x(){w()?void 0:h(!1,"useNavigate() may be used only in the context of a <Router> component.");let a=useContext(q).navigator,{pathname:b}=useContext(r),c=useRef(!1);useEffect(()=>{c.current=!0});return useCallback((d,e={})=>{c.current?"number"===typeof d?a.go(d):(d=F(d,b),(e.replace?a.replace:a.push)(d,e.state)):k(!1,"You should call navigate() in a useEffect, not when your component is first rendered.")},[a,b])}function z(){return useContext(r).outlet}
function G(a){let {pathname:b}=useContext(r);return useMemo(()=>F(a,b),[a,b])}
function D(a,b=""){let {route:c,pathname:d,params:e}=useContext(r);var f=c&&c.path;m(d,!c||c.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${f}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${f}"> to <Route path="${f}/*">.`);b=b?[d,b].join("/").replace(/\/\/+/g,"/"):d;
let g=E();return(f=useMemo(()=>H(a,g,b),[g,a,b]))?f.reduceRight((a,{params:c,pathname:d,route:f})=>createElement(r.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null):null}function I(a){return a.map(b=>{let a={path:b.path||"/",caseSensitive:!0===b.caseSensitive,element:b.element||createElement(y,null)};b.children&&(a.children=I(b.children));return a})}
function C(a){let b=[];Children.forEach(a,a=>{if(isValidElement(a))if(a.type===Fragment)b.push.apply(b,C(a.props.children));else{var c={path:a.props.path||"/",caseSensitive:!0===a.props.caseSensitive,element:a};a.props.children&&(a=C(a.props.children),a.length&&(c.children=a));b.push(c)}});return b}
function H(a,b,c=""){"string"===typeof b&&(b=parsePath(b));b=b.pathname||"/";if(c)if(c=c.replace(/^\/*/,"/").replace(/\/+$/,""),b.startsWith(c))b=b===c?"/":b.slice(c.length);else return null;a=J(a);K(a);var d=null;for(c=0;null==d&&c<a.length;++c)a:{d=b;let f=a[c][1],g="/",n={},p=[];for(let a=0;a<f.length;++a){let b=f[a];var e="/"===g?d:d.slice(g.length)||"/";e=L({path:b.path,caseSensitive:b.caseSensitive,end:a===f.length-1},e);if(!e){d=null;break a}g=[g,e.pathname].join("/").replace(/\/\/+/g,"/");
n={...n,...e.params};p.push({route:b,pathname:g,params:Object.freeze(n)})}d=p}return d}function J(a,b=[],c="",d=[],e=[]){a.forEach((a,g)=>{let f=[c,a.path].join("/").replace(/\/\/+/g,"/"),p=d.concat(a);g=e.concat(g);a.children&&J(a.children,b,f,p,g);b.push([f,p,g])});return b}function K(a){let b=a.reduce((a,[b])=>{a[b]=M(b);return a},{});N(a,(a,d)=>{let [c,,f]=a;a=b[c];let [g,,n]=d;d=b[g];return a!==d?d-a:O(f,n)})}let P=/^:\w+$/,Q=a=>"*"===a;
function M(a){a=a.split("/");let b=a.length;a.some(Q)&&(b+=-2);return a.filter(a=>"*"!==a).reduce((a,b)=>a+(P.test(b)?2:""===b?1:10),b)}function O(a,b){return a.length===b.length&&a.slice(0,-1).every((a,d)=>a===b[d])?a[a.length-1]-b[b.length-1]:0}function N(a,b){let c=a.slice(0);a.sort((a,e)=>b(a,e)||c.indexOf(a)-c.indexOf(e))}
function L(a,b){"string"===typeof a&&(a={path:a});let {path:c,caseSensitive:d=!1,end:e=!0}=a,[f,g]=R(c,d,e);b=b.match(f);if(!b)return null;a=b[1];let n=b.slice(2);b=g.reduce((a,b,c)=>{c=n[c];try{var d=decodeURIComponent(c.replace(/\+/g," "))}catch(S){k(!1,`The value for the URL param "${b}" will not be decoded because`+` the string "${c}" is a malformed URL segment. This is probably`+` due to a bad percent encoding (${S}).`),d=c}a[b]=d;return a},{});return{path:c,pathname:a,params:b}}
function R(a,b,c){let d=[],e="^("+a.replace(/^\/*/,"/").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):c&&(e+="\\/?");c&&(e+="$");return[new RegExp(e,b?void 0:"i"),d]}function F(a,b="/"){let {pathname:c,search:d="",hash:e=""}="string"===typeof a?parsePath(a):a;return{pathname:c?T(c,c.startsWith("/")?"/":b):b,search:d,hash:e}}
function T(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}
function generatePath(a,b={}){return a.replace(/:(\w+)/g,(a,d)=>{null==b[d]?h(!1,`Missing ":${d}" param`):void 0;return b[d]}).replace(/\/*\*$/,()=>null==b["*"]?"":b["*"].replace(/^\/*/,"/"))};
function useBlocker(a,b=!0){w()?void 0:h(!1,"useBlocker() may be used only in the context of a <Router> component.");let c=useContext(q).navigator;useEffect(()=>{if(b){var d=c.block(b=>{a({...b,retry(){d();b.retry()}})});return d}},[c,a,b])};function useHref(a){w()?void 0:h(!1,"useHref() may be used only in the context of a <Router> component.");let b=useContext(q).navigator;a=G(a);return b.createHref(a)};
function useMatch(a){w()?void 0:h(!1,"useMatch() may be used only in the context of a <Router> component.");let b=E();return L(a,b.pathname)};function useParams(){return useContext(r).params};function useRoutes(a,b=""){w()?void 0:h(!1,"useRoutes() may be used only in the context of a <Router> component.");let c=useMemo(()=>I(a),[a]);return D(c,b)};export{t as MemoryRouter,v as Navigate,y as Outlet,A as Route,u as Router,B as Routes,I as createRoutesFromArray,C as createRoutesFromChildren,generatePath,L as matchPath,H as matchRoutes,F as resolvePath,useBlocker,useHref,w as useInRouterContext,E as useLocation,useMatch,x as useNavigate,z as useOutlet,useParams,G as useResolvedPath,useRoutes}
//# sourceMappingURL=react-router.development.js.map
