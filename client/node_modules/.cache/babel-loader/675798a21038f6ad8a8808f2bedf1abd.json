{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport shallowEqual from '../utils/shallowEqual';\nimport stringToObject from '../utils/stringToObject';\nexport function getDerivedStateForCascade(nextProps, prevState, selectNodeValue, newChildren) {\n  var data = nextProps.data,\n      labelKey = nextProps.labelKey,\n      valueKey = nextProps.valueKey,\n      childrenKey = nextProps.childrenKey,\n      value = nextProps.value;\n  var activeItemValue = selectNodeValue || (typeof value === 'undefined' ? prevState.value : value);\n  var nextItems = [];\n  var nextPathItems = [];\n\n  var findNode = function findNode(items) {\n    var _loop = function _loop(i) {\n      items[i] = stringToObject(items[i], labelKey, valueKey);\n      var children = items[i][childrenKey];\n\n      if (shallowEqual(items[i][valueKey], activeItemValue)) {\n        return {\n          v: {\n            items: items,\n            active: items[i]\n          }\n        };\n      } else if (children) {\n        var v = findNode(children);\n\n        if (v) {\n          nextItems.push(children.map(function (item) {\n            return _extends({}, stringToObject(item, labelKey, valueKey), {\n              parent: items[i]\n            });\n          }));\n          nextPathItems.push(v.active);\n          return {\n            v: {\n              items: items,\n              active: items[i]\n            }\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < items.length; i += 1) {\n      var _ret = _loop(i);\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return null;\n  };\n\n  var activeItem = findNode(data);\n  nextItems.push(data);\n\n  if (activeItem) {\n    nextPathItems.push(activeItem.active);\n  }\n  /**\n   * 如果是异步更新 data 后，获取到的一个 selectNodeValue，则不更新 activePaths\n   * 但是需要更新 items， 因为这里的目的就是把异步更新后的的数据展示出来\n   */\n\n\n  var cascadePathItems = nextPathItems.reverse();\n\n  if (newChildren) {\n    return {\n      items: [].concat(nextItems.reverse(), [newChildren]),\n      tempActivePaths: cascadePathItems\n    };\n  }\n\n  return {\n    items: nextItems.reverse(),\n    tempActivePaths: null,\n    activePaths: cascadePathItems\n  };\n}","map":{"version":3,"sources":["E:/OneDrive - University of Salford/Desktop/pizza-website/node_modules/rsuite/es/Cascader/utils.js"],"names":["_extends","shallowEqual","stringToObject","getDerivedStateForCascade","nextProps","prevState","selectNodeValue","newChildren","data","labelKey","valueKey","childrenKey","value","activeItemValue","nextItems","nextPathItems","findNode","items","_loop","i","children","v","active","push","map","item","parent","length","_ret","activeItem","cascadePathItems","reverse","concat","tempActivePaths","activePaths"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport shallowEqual from '../utils/shallowEqual';\nimport stringToObject from '../utils/stringToObject';\nexport function getDerivedStateForCascade(nextProps, prevState, selectNodeValue, newChildren) {\n  var data = nextProps.data,\n      labelKey = nextProps.labelKey,\n      valueKey = nextProps.valueKey,\n      childrenKey = nextProps.childrenKey,\n      value = nextProps.value;\n  var activeItemValue = selectNodeValue || (typeof value === 'undefined' ? prevState.value : value);\n  var nextItems = [];\n  var nextPathItems = [];\n\n  var findNode = function findNode(items) {\n    var _loop = function _loop(i) {\n      items[i] = stringToObject(items[i], labelKey, valueKey);\n      var children = items[i][childrenKey];\n\n      if (shallowEqual(items[i][valueKey], activeItemValue)) {\n        return {\n          v: {\n            items: items,\n            active: items[i]\n          }\n        };\n      } else if (children) {\n        var v = findNode(children);\n\n        if (v) {\n          nextItems.push(children.map(function (item) {\n            return _extends({}, stringToObject(item, labelKey, valueKey), {\n              parent: items[i]\n            });\n          }));\n          nextPathItems.push(v.active);\n          return {\n            v: {\n              items: items,\n              active: items[i]\n            }\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < items.length; i += 1) {\n      var _ret = _loop(i);\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return null;\n  };\n\n  var activeItem = findNode(data);\n  nextItems.push(data);\n\n  if (activeItem) {\n    nextPathItems.push(activeItem.active);\n  }\n  /**\n   * 如果是异步更新 data 后，获取到的一个 selectNodeValue，则不更新 activePaths\n   * 但是需要更新 items， 因为这里的目的就是把异步更新后的的数据展示出来\n   */\n\n\n  var cascadePathItems = nextPathItems.reverse();\n\n  if (newChildren) {\n    return {\n      items: [].concat(nextItems.reverse(), [newChildren]),\n      tempActivePaths: cascadePathItems\n    };\n  }\n\n  return {\n    items: nextItems.reverse(),\n    tempActivePaths: null,\n    activePaths: cascadePathItems\n  };\n}"]},"metadata":{},"sourceType":"module"}