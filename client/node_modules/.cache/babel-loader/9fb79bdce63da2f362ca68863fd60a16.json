{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = _interopRequireDefault(require(\"./utils/calculateSizeAndPositionDataAndUpdateScrollOffset\"));\n\nvar _ScalingCellSizeAndPositionManager = _interopRequireDefault(require(\"./utils/ScalingCellSizeAndPositionManager\"));\n\nvar _createCallbackMemoizer = _interopRequireDefault(require(\"../utils/createCallbackMemoizer\"));\n\nvar _defaultOverscanIndicesGetter = _interopRequireWildcard(require(\"./defaultOverscanIndicesGetter\"));\n\nvar _updateScrollIndexHelper = _interopRequireDefault(require(\"./utils/updateScrollIndexHelper\"));\n\nvar _defaultCellRangeRenderer = _interopRequireDefault(require(\"./defaultCellRangeRenderer\"));\n\nvar _scrollbarSize = _interopRequireDefault(require(\"dom-helpers/scrollbarSize\"));\n\nvar _reactLifecyclesCompat = require(\"react-lifecycles-compat\");\n\nvar _requestAnimationTimeout = require(\"../utils/requestAnimationTimeout\");\n\nvar _types = require(\"./types\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\n\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = DEFAULT_SCROLLING_RESET_TIME_INTERVAL;\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\n\n\nvar Grid = (_temp = _class = /*#__PURE__*/function (_React$PureComponent) {\n  (0, _inherits2[\"default\"])(Grid, _React$PureComponent); // Invokes onSectionRendered callback only when start/stop row or column indices change\n\n  function Grid(props) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, Grid);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Grid).call(this, props));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onGridRenderedMemoizer\", (0, _createCallbackMemoizer[\"default\"])());\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onScrollMemoizer\", (0, _createCallbackMemoizer[\"default\"])(false));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_deferredInvalidateColumnIndex\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_deferredInvalidateRowIndex\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_recomputeScrollLeftFlag\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_recomputeScrollTopFlag\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_horizontalScrollBarSize\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_verticalScrollBarSize\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_scrollbarPresenceChanged\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_scrollingContainer\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_childrenToDisplay\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_columnStartIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_columnStopIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rowStartIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rowStopIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedColumnStartIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedColumnStopIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedRowStartIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedRowStopIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_initialScrollTop\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_initialScrollLeft\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_disablePointerEventsTimeoutId\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_styleCache\", {});\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_cellCache\", {});\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    });\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager[\"default\"]({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager[\"default\"]({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  (0, _createClass2[\"default\"])(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _objectSpread({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop; // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _this$props = this.props,\n          autoHeight = _this$props.autoHeight,\n          autoWidth = _this$props.autoWidth,\n          height = _this$props.height,\n          width = _this$props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n\n      var _this$props3 = this.props,\n          scrollToColumn = _this$props3.scrollToColumn,\n          scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          getScrollbarSize = _this$props4.getScrollbarSize,\n          height = _this$props4.height,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToColumn = _this$props4.scrollToColumn,\n          scrollTop = _this$props4.scrollTop,\n          scrollToRow = _this$props4.scrollToRow,\n          width = _this$props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread({}, prevState, {\n            needToResetStyleCache: false\n          });\n\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props5 = this.props,\n          autoHeight = _this$props5.autoHeight,\n          autoWidth = _this$props5.autoWidth,\n          columnCount = _this$props5.columnCount,\n          height = _this$props5.height,\n          rowCount = _this$props5.rowCount,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToColumn = _this$props5.scrollToColumn,\n          scrollToRow = _this$props5.scrollToRow,\n          width = _this$props5.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n          scrollTop = _this$state.scrollTop,\n          instanceProps = _this$state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        (0, _updateScrollIndexHelper[\"default\"])({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        (0, _updateScrollIndexHelper[\"default\"])({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoContainerWidth = _this$props6.autoContainerWidth,\n          autoHeight = _this$props6.autoHeight,\n          autoWidth = _this$props6.autoWidth,\n          className = _this$props6.className,\n          containerProps = _this$props6.containerProps,\n          containerRole = _this$props6.containerRole,\n          containerStyle = _this$props6.containerStyle,\n          height = _this$props6.height,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          role = _this$props6.role,\n          style = _this$props6.style,\n          tabIndex = _this$props6.tabIndex,\n          width = _this$props6.width;\n      var _this$state2 = this.state,\n          instanceProps = _this$state2.instanceProps,\n          needToResetStyleCache = _this$state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement(\"div\", (0, _extends2[\"default\"])({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: (0, _clsx[\"default\"])('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread({}, gridStyle, {}, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state; // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA;\n      var maybeStateB;\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset[\"default\"])({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset[\"default\"])({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return {};\n    }\n  }]);\n  return Grid;\n}(React.PureComponent), (0, _defineProperty2[\"default\"])(_class, \"propTypes\", process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": _propTypes[\"default\"].string.isRequired,\n  \"aria-readonly\": _propTypes[\"default\"].bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  \"autoContainerWidth\": _propTypes[\"default\"].bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoHeight\": _propTypes[\"default\"].bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoWidth\": _propTypes[\"default\"].bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  \"cellRenderer\": function cellRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRenderer === \"function\" ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  \"cellRangeRenderer\": function cellRangeRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === \"function\" ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  \"className\": _propTypes[\"default\"].string,\n\n  /** Number of columns in grid.  */\n  \"columnCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  \"columnWidth\": function columnWidth() {\n    return (typeof _types.bpfrpt_proptype_CellSize === \"function\" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  \"containerProps\": _propTypes[\"default\"].object,\n\n  /** ARIA role for the cell-container.  */\n  \"containerRole\": _propTypes[\"default\"].string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  \"containerStyle\": _propTypes[\"default\"].object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  \"deferredMeasurementCache\": _propTypes[\"default\"].object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  \"estimatedColumnSize\": _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  \"estimatedRowSize\": _propTypes[\"default\"].number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  \"getScrollbarSize\": _propTypes[\"default\"].func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  \"height\": _propTypes[\"default\"].number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  \"id\": _propTypes[\"default\"].string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  \"isScrolling\": _propTypes[\"default\"].bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  \"isScrollingOptOut\": _propTypes[\"default\"].bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  \"noContentRenderer\": function noContentRenderer() {\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === \"function\" ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  \"onScroll\": _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  \"onScrollbarPresenceChange\": _propTypes[\"default\"].func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  \"onSectionRendered\": _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanColumnCount\": _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  \"overscanIndicesGetter\": function overscanIndicesGetter() {\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === \"function\" ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanRowCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  \"role\": _propTypes[\"default\"].string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  \"rowHeight\": function rowHeight() {\n    return (typeof _types.bpfrpt_proptype_CellSize === \"function\" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  \"rowCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  \"scrollingResetTimeInterval\": _propTypes[\"default\"].number.isRequired,\n\n  /** Horizontal offset. */\n  \"scrollLeft\": _propTypes[\"default\"].number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  \"scrollToAlignment\": function scrollToAlignment() {\n    return (typeof _types.bpfrpt_proptype_Alignment === \"function\" ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToColumn\": _propTypes[\"default\"].number.isRequired,\n\n  /** Vertical offset. */\n  \"scrollTop\": _propTypes[\"default\"].number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToRow\": _propTypes[\"default\"].number.isRequired,\n\n  /** Optional inline style */\n  \"style\": _propTypes[\"default\"].object.isRequired,\n\n  /** Tab index for focus */\n  \"tabIndex\": _propTypes[\"default\"].number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  \"width\": _propTypes[\"default\"].number.isRequired\n}), _temp);\n(0, _defineProperty2[\"default\"])(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: _defaultCellRangeRenderer[\"default\"],\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: _scrollbarSize[\"default\"],\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: _defaultOverscanIndicesGetter[\"default\"],\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\n(0, _reactLifecyclesCompat.polyfill)(Grid);\nvar _default = Grid;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["E:/OneDrive - University of Salford/Desktop/pizza-website/node_modules/react-virtualized/dist/commonjs/Grid/Grid.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","Object","defineProperty","exports","value","DEFAULT_SCROLLING_RESET_TIME_INTERVAL","_extends2","_classCallCheck2","_createClass2","_possibleConstructorReturn2","_getPrototypeOf2","_assertThisInitialized2","_inherits2","_defineProperty2","React","_clsx","_calculateSizeAndPositionDataAndUpdateScrollOffset","_ScalingCellSizeAndPositionManager","_createCallbackMemoizer","_defaultOverscanIndicesGetter","_updateScrollIndexHelper","_defaultCellRangeRenderer","_scrollbarSize","_reactLifecyclesCompat","_requestAnimationTimeout","_types","_propTypes","_class","_temp","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","SCROLL_POSITION_CHANGE_REASONS","OBSERVED","REQUESTED","renderNull","Grid","_React$PureComponent","props","_this","call","_disablePointerEventsTimeoutId","setState","isScrolling","needToResetStyleCache","onSectionRendered","_onGridRenderedMemoizer","callback","indices","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","_renderedColumnStartIndex","columnStopIndex","_renderedColumnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","_renderedRowStartIndex","rowStopIndex","_renderedRowStopIndex","ref","_scrollingContainer","event","handleScrollEvent","columnSizeAndPositionManager","cellCount","columnCount","cellSizeGetter","params","_wrapSizeGetter","columnWidth","estimatedCellSize","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","state","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","scrollbarSize","scrollbarSizeMeasured","scrollDirectionHorizontal","SCROLL_DIRECTION_FORWARD","scrollDirectionVertical","scrollLeft","scrollTop","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","getOffsetForCell","_ref","undefined","_ref$alignment","alignment","scrollToAlignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","getTotalRowsHeight","getTotalSize","getTotalColumnsWidth","_ref2","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_this$props","autoHeight","autoWidth","height","width","totalRowsHeight","totalColumnsWidth","Math","min","max","SCROLL_DIRECTION_BACKWARD","newState","_invokeOnScrollMemoizer","invalidateCellSizeAfterRender","_ref3","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","measureAllCells","_this$props2","getSizeAndPositionOfCell","recomputeGridSize","_ref4","_ref4$columnIndex","_ref4$rowIndex","_this$props3","resetCell","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_styleCache","_cellCache","forceUpdate","scrollToCell","_ref5","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","componentDidMount","_this$props4","getScrollbarSize","_handleInvalidatedGridSize","prevState","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_invokeOnGridRenderedHelper","_maybeCallOnScrollbarPresenceChange","componentDidUpdate","prevProps","_this2","_this$props5","_this$state","columnOrRowCountJustIncreasedFromZero","sizeJustIncreasedFromZero","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToIndex","size","updateScrollIndexCallback","componentWillUnmount","cancelAnimationTimeout","render","_this$props6","autoContainerWidth","className","containerProps","containerRole","containerStyle","id","noContentRenderer","role","style","tabIndex","_this$state2","_isScrolling","gridStyle","boxSizing","direction","position","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","createElement","_setScrollingContainerRef","onScroll","_onScroll","maxWidth","maxHeight","overflow","pointerEvents","cellRenderer","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","getVisibleCellRange","containerSize","offset","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","start","stop","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","requestAnimationTimeout","_debounceScrollEndedCallback","_ref6","_this3","_onScrollMemoizer","_ref7","_this3$props","clientHeight","clientWidth","scrollHeight","scrollWidth","hasOwnProperty","Boolean","onScrollbarPresenceChange","horizontal","vertical","scrollToPosition","_ref8","_getScrollLeftForScrollToColumnStateUpdate","concat","_getScrollTopForScrollToRowStateUpdate","getDerivedStateFromProps","nextProps","assign","configure","maybeStateA","maybeStateB","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","updateScrollOffsetForScrollToIndex","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","targetIndex","scrollBarSize","getUpdatedOffsetForIndex","align","currentOffset","calculatedScrollLeft","finalRow","calculatedScrollTop","PureComponent","process","env","NODE_ENV","string","isRequired","bool","bpfrpt_proptype_CellRenderer","shape","bpfrpt_proptype_CellRangeRenderer","number","bpfrpt_proptype_CellSize","func","bpfrpt_proptype_NoContentRenderer","bpfrpt_proptype_OverscanIndicesGetter","bpfrpt_proptype_Alignment","polyfill","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _clsx = _interopRequireDefault(require(\"clsx\"));\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = _interopRequireDefault(require(\"./utils/calculateSizeAndPositionDataAndUpdateScrollOffset\"));\n\nvar _ScalingCellSizeAndPositionManager = _interopRequireDefault(require(\"./utils/ScalingCellSizeAndPositionManager\"));\n\nvar _createCallbackMemoizer = _interopRequireDefault(require(\"../utils/createCallbackMemoizer\"));\n\nvar _defaultOverscanIndicesGetter = _interopRequireWildcard(require(\"./defaultOverscanIndicesGetter\"));\n\nvar _updateScrollIndexHelper = _interopRequireDefault(require(\"./utils/updateScrollIndexHelper\"));\n\nvar _defaultCellRangeRenderer = _interopRequireDefault(require(\"./defaultCellRangeRenderer\"));\n\nvar _scrollbarSize = _interopRequireDefault(require(\"dom-helpers/scrollbarSize\"));\n\nvar _reactLifecyclesCompat = require(\"react-lifecycles-compat\");\n\nvar _requestAnimationTimeout = require(\"../utils/requestAnimationTimeout\");\n\nvar _types = require(\"./types\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _class, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = DEFAULT_SCROLLING_RESET_TIME_INTERVAL;\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = (_temp = _class =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  (0, _inherits2[\"default\"])(Grid, _React$PureComponent);\n\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\n  function Grid(props) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, Grid);\n    _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Grid).call(this, props));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onGridRenderedMemoizer\", (0, _createCallbackMemoizer[\"default\"])());\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onScrollMemoizer\", (0, _createCallbackMemoizer[\"default\"])(false));\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_deferredInvalidateColumnIndex\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_deferredInvalidateRowIndex\", null);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_recomputeScrollLeftFlag\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_recomputeScrollTopFlag\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_horizontalScrollBarSize\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_verticalScrollBarSize\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_scrollbarPresenceChanged\", false);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_scrollingContainer\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_childrenToDisplay\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_columnStartIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_columnStopIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rowStartIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_rowStopIndex\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedColumnStartIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedColumnStopIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedRowStartIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_renderedRowStopIndex\", 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_initialScrollTop\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_initialScrollLeft\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_disablePointerEventsTimeoutId\", void 0);\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_styleCache\", {});\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_cellCache\", {});\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_debounceScrollEndedCallback\", function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_invokeOnGridRenderedHelper\", function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_setScrollingContainerRef\", function (ref) {\n      _this._scrollingContainer = ref;\n    });\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_onScroll\", function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    });\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager[\"default\"]({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager[\"default\"]({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  (0, _createClass2[\"default\"])(Grid, [{\n    key: \"getOffsetForCell\",\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _objectSpread({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: \"getTotalRowsHeight\",\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: \"getTotalColumnsWidth\",\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: \"handleScrollEvent\",\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;\n\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _this$props = this.props,\n          autoHeight = _this$props.autoHeight,\n          autoWidth = _this$props.autoWidth,\n          height = _this$props.height,\n          width = _this$props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: scrollDirectionHorizontal,\n          scrollDirectionVertical: scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: \"invalidateCellSizeAfterRender\",\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: \"measureAllCells\",\n    value: function measureAllCells() {\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          rowCount = _this$props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: \"recomputeGridSize\",\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;\n\n      var _this$props3 = this.props,\n          scrollToColumn = _this$props3.scrollToColumn,\n          scrollToRow = _this$props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_objectSpread({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props4 = this.props,\n          getScrollbarSize = _this$props4.getScrollbarSize,\n          height = _this$props4.height,\n          scrollLeft = _this$props4.scrollLeft,\n          scrollToColumn = _this$props4.scrollToColumn,\n          scrollTop = _this$props4.scrollTop,\n          scrollToRow = _this$props4.scrollToRow,\n          width = _this$props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _objectSpread({}, prevState, {\n            needToResetStyleCache: false\n          });\n\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props5 = this.props,\n          autoHeight = _this$props5.autoHeight,\n          autoWidth = _this$props5.autoWidth,\n          columnCount = _this$props5.columnCount,\n          height = _this$props5.height,\n          rowCount = _this$props5.rowCount,\n          scrollToAlignment = _this$props5.scrollToAlignment,\n          scrollToColumn = _this$props5.scrollToColumn,\n          scrollToRow = _this$props5.scrollToRow,\n          width = _this$props5.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollPositionChangeReason = _this$state.scrollPositionChangeReason,\n          scrollTop = _this$state.scrollTop,\n          instanceProps = _this$state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        (0, _updateScrollIndexHelper[\"default\"])({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        (0, _updateScrollIndexHelper[\"default\"])({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          autoContainerWidth = _this$props6.autoContainerWidth,\n          autoHeight = _this$props6.autoHeight,\n          autoWidth = _this$props6.autoWidth,\n          className = _this$props6.className,\n          containerProps = _this$props6.containerProps,\n          containerRole = _this$props6.containerRole,\n          containerStyle = _this$props6.containerStyle,\n          height = _this$props6.height,\n          id = _this$props6.id,\n          noContentRenderer = _this$props6.noContentRenderer,\n          role = _this$props6.role,\n          style = _this$props6.style,\n          tabIndex = _this$props6.tabIndex,\n          width = _this$props6.width;\n      var _this$state2 = this.state,\n          instanceProps = _this$state2.instanceProps,\n          needToResetStyleCache = _this$state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement(\"div\", (0, _extends2[\"default\"])({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        \"aria-label\": this.props['aria-label'],\n        \"aria-readonly\": this.props['aria-readonly'],\n        className: (0, _clsx[\"default\"])('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _objectSpread({}, gridStyle, {}, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement(\"div\", {\n        className: \"ReactVirtualized__Grid__innerScrollContainer\",\n        role: containerRole,\n        style: _objectSpread({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: \"_calculateChildrenToRender\",\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: \"_debounceScrollEnded\",\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: \"_handleInvalidatedGridSize\",\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: \"_invokeOnScrollMemoizer\",\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _this3$props = _this3.props,\n              height = _this3$props.height,\n              onScroll = _this3$props.onScroll,\n              width = _this3$props.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: \"_isScrolling\",\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: \"_maybeCallOnScrollbarPresenceChange\",\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n        onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: \"_updateScrollLeftForScrollToColumn\",\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: \"_resetStyleCache\",\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateScrollTopForScrollToRow\",\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        Object.assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps; // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        Object.assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA;\n      var maybeStateB;\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset[\"default\"])({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset[\"default\"])({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);\n    }\n  }, {\n    key: \"_getEstimatedColumnSize\",\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: \"_getEstimatedRowSize\",\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: \"_getScrollToPositionStateUpdate\",\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_wrapSizeGetter\",\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: \"_getCalculatedScrollLeft\",\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollLeftForScrollToColumnStateUpdate\",\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return {};\n    }\n  }, {\n    key: \"_getCalculatedScrollTop\",\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_getScrollTopForScrollToRowStateUpdate\",\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return {};\n    }\n  }]);\n  return Grid;\n}(React.PureComponent), (0, _defineProperty2[\"default\"])(_class, \"propTypes\", process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": _propTypes[\"default\"].string.isRequired,\n  \"aria-readonly\": _propTypes[\"default\"].bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  \"autoContainerWidth\": _propTypes[\"default\"].bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoHeight\": _propTypes[\"default\"].bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  \"autoWidth\": _propTypes[\"default\"].bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  \"cellRenderer\": function cellRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRenderer === \"function\" ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  \"cellRangeRenderer\": function cellRangeRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === \"function\" ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  \"className\": _propTypes[\"default\"].string,\n\n  /** Number of columns in grid.  */\n  \"columnCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  \"columnWidth\": function columnWidth() {\n    return (typeof _types.bpfrpt_proptype_CellSize === \"function\" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  \"containerProps\": _propTypes[\"default\"].object,\n\n  /** ARIA role for the cell-container.  */\n  \"containerRole\": _propTypes[\"default\"].string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  \"containerStyle\": _propTypes[\"default\"].object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  \"deferredMeasurementCache\": _propTypes[\"default\"].object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  \"estimatedColumnSize\": _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  \"estimatedRowSize\": _propTypes[\"default\"].number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  \"getScrollbarSize\": _propTypes[\"default\"].func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  \"height\": _propTypes[\"default\"].number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  \"id\": _propTypes[\"default\"].string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  \"isScrolling\": _propTypes[\"default\"].bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  \"isScrollingOptOut\": _propTypes[\"default\"].bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  \"noContentRenderer\": function noContentRenderer() {\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === \"function\" ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  \"onScroll\": _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  \"onScrollbarPresenceChange\": _propTypes[\"default\"].func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  \"onSectionRendered\": _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanColumnCount\": _propTypes[\"default\"].number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  \"overscanIndicesGetter\": function overscanIndicesGetter() {\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === \"function\" ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  \"overscanRowCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  \"role\": _propTypes[\"default\"].string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  \"rowHeight\": function rowHeight() {\n    return (typeof _types.bpfrpt_proptype_CellSize === \"function\" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  \"rowCount\": _propTypes[\"default\"].number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  \"scrollingResetTimeInterval\": _propTypes[\"default\"].number.isRequired,\n\n  /** Horizontal offset. */\n  \"scrollLeft\": _propTypes[\"default\"].number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  \"scrollToAlignment\": function scrollToAlignment() {\n    return (typeof _types.bpfrpt_proptype_Alignment === \"function\" ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes[\"default\"].shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToColumn\": _propTypes[\"default\"].number.isRequired,\n\n  /** Vertical offset. */\n  \"scrollTop\": _propTypes[\"default\"].number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  \"scrollToRow\": _propTypes[\"default\"].number.isRequired,\n\n  /** Optional inline style */\n  \"style\": _propTypes[\"default\"].object.isRequired,\n\n  /** Tab index for focus */\n  \"tabIndex\": _propTypes[\"default\"].number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  \"width\": _propTypes[\"default\"].number.isRequired\n}), _temp);\n(0, _defineProperty2[\"default\"])(Grid, \"defaultProps\", {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: _defaultCellRangeRenderer[\"default\"],\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: _scrollbarSize[\"default\"],\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: _defaultOverscanIndicesGetter[\"default\"],\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n});\n(0, _reactLifecyclesCompat.polyfill)(Grid);\nvar _default = Grid;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}