{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = defaultOverscanIndicesGetter;\nexports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;\n\nvar _types = require(\"./types\");\n\nvar SCROLL_DIRECTION_BACKWARD = -1;\nexports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;\nvar SCROLL_DIRECTION_FORWARD = 1;\nexports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;\nvar SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;\nvar SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;\n\nfunction defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex)\n    };\n  }\n}","map":{"version":3,"sources":["E:/OneDrive - University of Salford/Desktop/pizza-website/node_modules/react-virtualized/dist/commonjs/Grid/defaultOverscanIndicesGetter.js"],"names":["Object","defineProperty","exports","value","defaultOverscanIndicesGetter","SCROLL_DIRECTION_VERTICAL","SCROLL_DIRECTION_HORIZONTAL","SCROLL_DIRECTION_FORWARD","SCROLL_DIRECTION_BACKWARD","_types","require","_ref","cellCount","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanStartIndex","Math","max","overscanStopIndex","min"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,4BAArB;AACAF,OAAO,CAACG,yBAAR,GAAoCH,OAAO,CAACI,2BAAR,GAAsCJ,OAAO,CAACK,wBAAR,GAAmCL,OAAO,CAACM,yBAAR,GAAoC,KAAK,CAAtJ;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIF,yBAAyB,GAAG,CAAC,CAAjC;AACAN,OAAO,CAACM,yBAAR,GAAoCA,yBAApC;AACA,IAAID,wBAAwB,GAAG,CAA/B;AACAL,OAAO,CAACK,wBAAR,GAAmCA,wBAAnC;AACA,IAAID,2BAA2B,GAAG,YAAlC;AACAJ,OAAO,CAACI,2BAAR,GAAsCA,2BAAtC;AACA,IAAID,yBAAyB,GAAG,UAAhC;AACA;AACA;AACA;AACA;;AAEAH,OAAO,CAACG,yBAAR,GAAoCA,yBAApC;;AAEA,SAASD,4BAAT,CAAsCO,IAAtC,EAA4C;AAC1C,MAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;AAAA,MACIC,kBAAkB,GAAGF,IAAI,CAACE,kBAD9B;AAAA,MAEIC,eAAe,GAAGH,IAAI,CAACG,eAF3B;AAAA,MAGIC,UAAU,GAAGJ,IAAI,CAACI,UAHtB;AAAA,MAIIC,SAAS,GAAGL,IAAI,CAACK,SAJrB;;AAMA,MAAIF,eAAe,KAAKP,wBAAxB,EAAkD;AAChD,WAAO;AACLU,MAAAA,kBAAkB,EAAEC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYJ,UAAZ,CADf;AAELK,MAAAA,iBAAiB,EAAEF,IAAI,CAACG,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAS,GAAGH,kBAApC;AAFd,KAAP;AAID,GALD,MAKO;AACL,WAAO;AACLI,MAAAA,kBAAkB,EAAEC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYJ,UAAU,GAAGF,kBAAzB,CADf;AAELO,MAAAA,iBAAiB,EAAEF,IAAI,CAACG,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAxB;AAFd,KAAP;AAID;AACF","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = defaultOverscanIndicesGetter;\nexports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;\n\nvar _types = require(\"./types\");\n\nvar SCROLL_DIRECTION_BACKWARD = -1;\nexports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;\nvar SCROLL_DIRECTION_FORWARD = 1;\nexports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;\nvar SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;\nvar SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;\n\nfunction defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex)\n    };\n  }\n}"]},"metadata":{},"sourceType":"script"}