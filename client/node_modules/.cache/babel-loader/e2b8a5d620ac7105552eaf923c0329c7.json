{"ast":null,"code":"export function setInlineStyles(node, styles) {\n  if (styles !== null) {\n    Object.keys(styles).forEach(function (key) {\n      if (node !== null) {\n        node.style[key] = styles[key];\n      }\n    });\n  }\n}\nexport function setTranslate3d(node, translate) {\n  if (node !== null) {\n    node.style['transform'] = translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : '';\n  }\n}\nexport function setTransitionDuration(node, duration) {\n  if (node !== null) {\n    node.style['transitionDuration'] = duration ? duration + \"ms\" : '';\n  }\n}\n\nfunction isScrollable(el) {\n  var computedStyle = window.getComputedStyle(el);\n  var overflowRegex = /(auto|scroll)/;\n  var properties = ['overflow', 'overflowX', 'overflowY'];\n  return properties.find(function (property) {\n    return overflowRegex.test(computedStyle[property]);\n  });\n}\n\nexport function closest(el, fn) {\n  while (el) {\n    if (fn(el)) {\n      return el;\n    }\n\n    el = el instanceof Element && el.parentNode;\n  }\n\n  return null;\n}\nexport function getPosition(event) {\n  return {\n    x: event.pageX || 0,\n    y: event.pageY || 0\n  };\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: offset.left + node.offsetLeft,\n    top: offset.top + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  if (!(el instanceof HTMLElement)) {\n    return null;\n  } else if (isScrollable(el)) {\n    return el;\n  } else {\n    return getScrollingParent(el.parentNode);\n  }\n}","map":{"version":3,"sources":["E:/OneDrive - University of Salford/Desktop/pizza-website/node_modules/rsuite/es/List/utils.js"],"names":["setInlineStyles","node","styles","Object","keys","forEach","key","style","setTranslate3d","translate","x","y","setTransitionDuration","duration","isScrollable","el","computedStyle","window","getComputedStyle","overflowRegex","properties","find","property","test","closest","fn","Element","parentNode","getPosition","event","pageX","pageY","getEdgeOffset","parent","offset","left","top","nodeOffset","offsetLeft","offsetTop","getScrollingParent","HTMLElement"],"mappings":"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","sourcesContent":["export function setInlineStyles(node, styles) {\n  if (styles !== null) {\n    Object.keys(styles).forEach(function (key) {\n      if (node !== null) {\n        node.style[key] = styles[key];\n      }\n    });\n  }\n}\nexport function setTranslate3d(node, translate) {\n  if (node !== null) {\n    node.style['transform'] = translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : '';\n  }\n}\nexport function setTransitionDuration(node, duration) {\n  if (node !== null) {\n    node.style['transitionDuration'] = duration ? duration + \"ms\" : '';\n  }\n}\n\nfunction isScrollable(el) {\n  var computedStyle = window.getComputedStyle(el);\n  var overflowRegex = /(auto|scroll)/;\n  var properties = ['overflow', 'overflowX', 'overflowY'];\n  return properties.find(function (property) {\n    return overflowRegex.test(computedStyle[property]);\n  });\n}\n\nexport function closest(el, fn) {\n  while (el) {\n    if (fn(el)) {\n      return el;\n    }\n\n    el = el instanceof Element && el.parentNode;\n  }\n\n  return null;\n}\nexport function getPosition(event) {\n  return {\n    x: event.pageX || 0,\n    y: event.pageY || 0\n  };\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: offset.left + node.offsetLeft,\n    top: offset.top + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  if (!(el instanceof HTMLElement)) {\n    return null;\n  } else if (isScrollable(el)) {\n    return el;\n  } else {\n    return getScrollingParent(el.parentNode);\n  }\n}"]},"metadata":{},"sourceType":"module"}